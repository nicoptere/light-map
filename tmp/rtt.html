
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        html, body
        {
            margin:0;
            overflow:hidden;
            width:100%;
            height:100%;
        }
        #canvas
        {
            background-color: #000000;
             margin: auto;
             position: absolute;
             top: 0; left: 0; bottom: 0; right: 0;
         }
    </style>
</head>
<body>
<script src="glsl/ShaderLoader.js"></script>
<script src="../example/light-map.min.js"></script>


<canvas id="canvas" ></canvas>
<script type="text/javascript">

    function initWebgl(canvas)
    {
        var gl;
        try { gl = canvas.getContext("webgl"); } catch (e) { }
        if (!gl) console("Could not initialise WebGL, sorry :-(");
        return gl;
    }


    function createShader(gl, id, type)
    {
        var src = ShaderLoader.get( id );//document.getElementById(id).firstChild.textContent;
        var shader = gl.createShader(type);

        gl.shaderSource(shader, src);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    function initProgram(gl, vertexShader, fragmentShader)
    {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.log("Could not initialise shaders");
        }

        gl.useProgram(program);

        program.vertexPositionAttribute = gl.getAttribLocation( program, "aVertexPosition" );
        gl.enableVertexAttribArray(program.vertexPositionAttribute);

        return program;
    }

    function initTextures( src, id ) {
        var img = new Image();
        img.onload = function()
        {
            onTextureLoaded( img, id );
        };
        img.src = src ;
    }

    function onTextureLoaded( image, id ) {

        var texture = createAndSetupTexture( gl );
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture(gl.TEXTURE_2D, texture);

    }



    function createAndSetupTexture(gl) {

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set up texture so we can render any size image and so we are working with pixels.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        return texture;
    }

    function drawScene(gl, canvas, program, uniforms, attributes, iGlobalTime)
    {
        checkSize(canvas);

       // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.uniform1f( uniforms.iGlobalTime, iGlobalTime );
        gl.uniform1i( uniforms.iChannel0, 0 );

        gl.bindBuffer(gl.ARRAY_BUFFER, attributes.vertices);
        gl.vertexAttribPointer(program.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    }


    function checkSize(c)
    {
        c.width = map.width;
        c.height = map.height;

        gl.viewport(0, 0, c.width, c.height);
        gl.uniform2f( uniforms.iResolution, c.width, c.height);
    }


    var gl;
    var vertexShader;
    var fragmentShader;
    var program;

    var canvas = document.getElementById("canvas");
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;


    var iGlobalTime = 0;
    var texture = 0;
    var startTime = Date.now();
    var randomSeed = Math.random();


    var attributes;
    var uniforms;

    var provider, domains;
    provider = "http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
    provider = "http://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png";
    provider = "http://ttiles{s}.mqcdn.com/tiles/1.0.0/vy/sat/{z}/{x}/{y}.png";
    domains = "a,b,c".split( ',' );
    domains = "01,02,03,04".split( ',' );
    var map = new Map( provider, domains, 1024, 1024,0,18 );
    map.setView(48,3,12);

    window.onload = function()
    {

        var sl = new ShaderLoader();
        var shaders =
        {
            vertex: '',
            crt: ''
        };
        sl.loadShaders( shaders, "./glsl/", init );

    };

    function init()
    {

        gl = initWebgl(canvas);

        vertexShader = createShader( gl, "vertex", gl.VERTEX_SHADER);
        fragmentShader = createShader(gl, "crt", gl.FRAGMENT_SHADER);

        program = initProgram(gl, vertexShader, fragmentShader);

        attributes = {
            vertices : gl.createBuffer()
        };

        uniforms = {
            iResolution : gl.getUniformLocation( program, "iResolution" ),
            iGlobalTime : gl.getUniformLocation( program, "iGlobalTime" ),
            iChannel0 : gl.getUniformLocation( program, "iChannel0" ),
            iChannel1 : gl.getUniformLocation( program, "iChannel1" )
        };

        var texture = createAndSetupTexture( gl );
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, map.canvas );
        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture(gl.TEXTURE_2D, texture);

        map.eventEmitter.on( Map.ON_TEXTURE_UPDATE, updateTexture );


        gl.bindBuffer(gl.ARRAY_BUFFER, attributes.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 1, 1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        update();

    }


    function updateTexture()
    {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, map.canvas );
    }

    function update()
    {

        var t = Date.now() * 0.001;
        var ct = Math.cos( t );
        var st = Math.sin( t );

        iGlobalTime = ( Date.now() - startTime ) * 0.001;
        drawScene(gl, canvas, program, uniforms, attributes, iGlobalTime);
        requestAnimationFrame(update);
    }

</script>
</body>
</html>